# Creating Dungeon Crawler Python Test Game

# Imports
import numpy as np
import math
import pyinputplus as pyip

# TODO Add Static Variables Here

# Organisms

class Character:
  def __init__(self, name, max_hp, hp, dmg, crit):
    # TODO Road Plan: Add MP/Max MP
    self.name = name
    self.max_hp = max_hp
    self.hp = hp
    self.dmg = dmg
    self.crit = crit

  # TODO All Function Descriptions
  def restore_health(self, restore_val):
    self.hp = min(self.hp+restore_val, self.max_hp)

  def attack(self, other):
    dmg = self.dmg * np.random.choice([1, 2], p=[1-self.crit, self.crit])
    other.hp -= dmg


# Heroes

class Hero(Character):
  def __init__(self, player_name, name, max_hp, hp, left_hand, right_hand, gold):
    self.player_name = player_name
    super().__init__(name)
    super().__init__(max_hp)
    super().__init__(hp)
    self.kill_count = 0 # Number of enemies killed to scale enemy difficulty with player progression
    self.left_hand = left_hand
    self.right_hand = right_hand
    self.gold = 0

  def increase_health(self, increase_val):
    self.max_hp += increase_val
    self.hp += increase_val
    # TODO Add dialogue

  def increase_gold(self, increase_val):
    self.gold += increase_val
    # TODO Add dialogue

  def add_item(self, item):
    if item.__mro__ is Weapon:
      if not self.left_hand:
        hand = 'left'
        self.left_hand = item
      else:
        # TODO Add dialogue and stats for both weapons
        hand = pyip.inputMenu(['Left', 'Right', 'Neither'], '')
        if hand == 'left':
          self.left_hand = item
        elif hand == 'right':
          self.right_hand = item
        else:
          print() # TODO Discard Dialogue

      print() # TODO Add dialogue using hand designation

  def attack(self, other, attack_name):
    if attack_name in self.right_hand.move_list:
      _, dmg = self.right_hand.attack(attack_name)
    else:
      _, dmg = self.left_hand.attack(attack_name)

    other.hp -= dmg
    print() # Attack Description

  # TODO Road Plan: Special Moves Functions

class Corporate(Hero):
  def __init__(self, name, hp, left_hand, right_hand, gold):
    self.name = 'Corporate'
    self.max_hp = self.hp = 15
    self.dmg = 2
    self.crit = 0.1
    self.left_hand = None
    self.right_hand = NanoSword()
    self.gold = 4

class Punk(Hero):
  def __init__(self, name, hp, left_hand, right_hand, gold):
    self.name = 'Punk'
    self.max_hp = self.hp = 12
    self.dmg = 2
    self.crit = 0.2
    self.left_hand = None
    self.right_hand = Hammer()
    self.gold = 2

class Detective(Hero):
  def __init__(self, name, hp, left_hand, right_hand, gold):
    self.name = 'Detective'
    self.max_hp = self.hp = 17
    self.dmg = 1
    self.crit = 0.15
    self.left_hand = None
    self.right_hand = LaserGun()
    self.gold = 0


# Enemies

class Enemy(Character):
  def __init__(self, name, max_hp, hp, dmg, crit, floor, kill_count):
    super().__init__(name)
    super().__init__(max_hp)
    super().__init__(hp)
    super().__init__(dmg)
    super().__init__(crit)
    self.moves = {}
    self.floor = floor
    self.kill_count = kill_count

class Agent(Enemy):
  def __init__(self, floor, kill_count):
    self.name = 'Agent'
    self.max_hp = self.hp = 10
    self.dmg = math.ceil(1*0.75*floor) + np.random.choice(range(floor-1, kill_count // 6))
    self.crit = min(0.5, 0.07 + (0.03*floor) + (0.02 * np.random.poisson(range(floor-1, kill_count // 6)))) # Random Choice Instead?
  
  def attack(self, other):
    def gunshot(dmg, crit): 
      return 'Gunshot', dmg + 2 * np.random.choice([1, 2], p=[1-crit, crit])

    def karate(dmg, crit): 
      new_crit = crit+0.05
      return 'Karate', dmg + 1 * np.random.choice([1, 2], p=[1-new_crit, new_crit])

    attack_name, dmg = np.random.choice([gunshot, karate])(self.dmg, self.crit)
    other.hp -= dmg
    print() # Attack Description
      

class LabBeast(Enemy):
  def __init__(self, floor, kill_count):
    self.name = 'Lab Beast'
    self.max_hp = self.hp = 8
    self.dmg = math.ceil(2*0.75*floor) + np.random.choice(range(floor-1, kill_count // 6))
    self.crit = min(0.5, 0.03 + (0.02*floor) + (0.02 * np.random.poisson(range(floor-1, kill_count // 6)))) # Random Choice Instead?
    super().__init__(floor)
    super().__init__(kill_count)

  def attack(self, other):
    def claw_strike(dmg, crit): 
      return 'Claw Strike', dmg + 2 * np.random.choice([1, 2], p=[1-crit, crit])
    
    def tail_whip(dmg, crit): 
      new_crit = crit+0.03
      return 'Tail Whip', dmg + 1 * np.random.choice([1, 2], p=[1-new_crit, new_crit])

    attack_name, dmg = np.random.choice([claw_strike, tail_whip])(self.dmg, self.crit)
    other.hp -= dmg
    print() # Attack Description
   

class Mutant(Enemy):
  def __init__(self, floor, kill_count):
    self.name = 'Mutant'
    self.max_hp = self.hp = 12
    self.dmg = math.ceil(1*0.75*floor) + np.random.choice(range(floor-1, kill_count // 6))
    self.crit = min(0.5, 0.12 + (0.04*floor) + (0.02 * np.random.poisson(range(floor-1, kill_count // 6)))) # Random Choice Instead?
    super().__init__(floor)
    super().__init__(kill_count)

  def attack(self, other):
    def ooze(dmg, crit): 
      return 'Ooze', dmg + 2
    
    def body_crash(dmg, crit): 
      new_crit = crit+0.2
      return 'Body Crash', dmg + 2 * np.random.choice([1, 2], p=[1-new_crit, new_crit])

    attack_name, dmg = np.random.choice([ooze, body_crash])(self.dmg, self.crit)
    other.hp -= dmg
    print() # Attack Description

  # Road Plan: Suffocate insta-kill move

# TODO Road Plan: This Class
# class Android(Enemy):
#   def __init__(self, name, hp, dmg, crit, move_a, move_b):
#     self.name = 'Android'
#     super().__init__(hp)
#     super().__init__(dmg)
#     super().__init__(crit)
#     self.move_a = move_a
#     self.move_b = move_b

#  # TODO Create Moves

# TODO Road Plan: This Class
# class Machine(Enemy):
#   def __init__(self, name, hp, dmg, crit, move_a, move_b):
#     self.name = 'Machine'
#     super().__init__(hp)
#     super().__init__(dmg)
#     super().__init__(crit)
#     self.move_a = move_a
#     self.move_b = move_b

#  # TODO Create Moves

# Bosses

class Boss(Enemy):
  def __init__(self, name, hp, dmg, crit):
    super().__init__(name)
    super().__init__(hp)
    super().__init__(dmg)
    super().__init__(crit)

class EvilScientist(Boss):
  def __init__(self):
    self.name = 'Evil Scientist'
    self.hp = 20
    self.dmg = 3
    self.crit = 0.15

  def attack(self, other):
    def chemical_flask(dmg, crit): 
      return 'Chemical Flask', dmg + 2
    
    def tesla_coil(dmg, crit): 
      new_crit = crit+0.1
      return 'Tesla Coil', dmg + 1 * np.random.choice([1, 2], p=[1-new_crit, new_crit])
    
    def nano_bots(dmg, crit): 
      return 'Nano Bots', dmg + 1 * np.random.choice([1, 2], p=[1-crit, crit])

    attack_name, dmg = np.random.choice([chemical_flask, tesla_coil, nano_bots])(self.dmg, self.crit)
    other.hp -= dmg
    print() # Attack Description

# Weapons

class Weapon:
  def __init__(self, name, dmg, crit, cost):
    self.name = name
    self.dmg = dmg
    self.crit = crit
    self.move_list = []
    self.cost = cost

class NanoSword(Weapon):
  def __init__(self, floor, kill_count, cost):
    self.name = 'Nano Sword'
    self.dmg = math.ceil(2*0.75*floor) + np.random.choice(range(floor-1, kill_count // 4))
    self.crit = min(0.75, 0.04 + (0.03*floor) + (0.03 * np.random.poisson(range(floor-1, kill_count // 4)))) # Random Choice Instead?
    self.move_list = ['Fire Slash', 'Needle Strike']
    super().__init__(cost)

  def attack(self, attack_name):
    def fire_slash(dmg, crit): 
      return 'Fire Slash', dmg + 2 * np.random.choice([1, 2], p=[1-crit, crit])
    
    def needle_strike(dmg, crit): 
      new_crit = crit+0.3
      return 'Needle Strike', dmg + 1 * np.random.choice([1, 2], p=[1-new_crit, new_crit])

    return dict(zip(self.move_list, [fire_slash, needle_strike]))[attack_name](self.dmg, self.crit)
  

class LaserGun(Weapon):
  def __init__(self, floor, kill_count, move_a, move_b, crit_chance, cost):
    self.name = 'Laser Gun'
    self.dmg = math.ceil(3*0.75*floor) + np.random.choice(range(floor-1, kill_count // 4))
    self.crit = min(0.75, 0.05 + (0.02*floor) + (0.02 * np.random.poisson(range(floor-1, kill_count // 4)))) # Random Choice Instead?
    self.move_list = ['Gunshot', 'Laser Beam']
    super().__init__(cost)

  def attack(self, attack_name):
    def gunshot(dmg, crit):
      return 'Gunshot', dmg + 2
    
    def laser_beam(dmg, crit):
      new_crit = crit+0.1
      return 'Laser Beam', dmg + 1 * np.random.choice([1, 2], p=[1-new_crit, new_crit])

    return dict(zip(self.move_list, [gunshot, laser_beam]))[attack_name](self.dmg, self.crit)
    

class Hammer(Weapon):
  def __init__(self, floor, kill_count, move_a, move_b, crit_chance, cost):
    self.name = 'Hammer'
    self.dmg = math.ceil(3*0.75*floor) + np.random.choice(range(floor-1, kill_count // 4))
    self.crit = min(0.75, 0.08 + (0.03*floor) + (0.04 * np.random.poisson(range(floor-1, kill_count // 4)))) # Random Choice Instead?
    self.move_list = ['Hammer Rush', 'Nail Strike']
    super().__init__(cost)
    super().__init__(floor)
    super().__init__(kill_count)

  def attack(self, attack_name):
    def hammer_rush(dmg, crit):
      return 'Hammer Rush', dmg + 1 * np.random.choice([1, 2], p=[1-crit, crit]) * np.random.choice([1, 2], p=[1-crit, crit])
    
    def nail_strike(dmg, crit):
      new_crit = crit+0.25
      return 'Nail Strike', dmg + 2 * np.random.choice([1, 2], p=[1-new_crit, new_crit])

    return dict(zip(self.move_list, [hammer_rush, nail_strike]))[attack_name](self.dmg, self.crit)
    
# TODO Road Plan: This Class
# class BioGun(Weapon):
#   def __init__(self, floor, kill_count, move_a, move_b, crit_chance, cost):
#     self.name = 'Bio-Gun'
#     super().__init__(move_a)
#     super().__init__(move_b)
#     super().__init__(crit_chance)
#     super().__init__(cost)
#     super().__init__(floor)
#     super().__init__(kill_count)

#   # Create Move

# Rooms()

class Room:
  def __init__(self, floor):
    self.connections = {}
    self.north = None
    self.east = None
    self.south = None
    self.west = None
    self.floor = floor
    self.hero = None
    self.generated = False
    self.enemy = None
    self.items = {}

  def connect(self, north, east, south, west):
    self.connections['north'] = north
    self.connections['east'] = east
    self.connections['south'] = south
    self.connections['west'] = west

  def enter(self, hero, furnish_num=0):
    self.hero = hero
    self.furnish(self.floor, hero.kill_count, furnish_num)
    self.generated = True

  def furnish(self, floor, kill_count, num_items):
    shop_items = np.random.choice([NanoSword, LaserGun, Hammer, self.organ_calc], num_items, False)(floor, kill_count)
    for item in shop_items:
      if isinstance(item, int):
        self.items['Organ'] = item
      else:
        self.items[item.__name__] = item

  def upgrade(self, prices={}):
    # TODO Dialogue telling gold amount and item's stats
    if len(self.items.keys) == 1:
      pyip.inputYesNo() # TODO Add Dialogue for 1 Item
    else:
      upgrade_path = pyip.inputMenu(self.items.keys(), '')    
  
    if upgrade_path == 'Organ':
      self.hero.increase_health(self.items[upgrade_path])
    elif upgrade_path == 'Gold':
      self.hero.increase_gold(self.items[upgrade_path])
    elif upgrade_path in [weapon.__name__ for weapon in Weapon.__subclasses__()]: # TODO Better Place to Put This?
      self.hero.add_item(self.items[upgrade_path])
    
    self.increase_gold(prices.get(upgrade_path, 0) * -1) # Decrease Amount by Price if Shopping

    return upgrade_path
  

  def exit(self):

    direction = None
    while not direction:
      # TODO Add Dialogue stating available directions
      direction = self.connections[pyip.inputMenu(['north', 'east', 'south', 'west'], '')] # TODO Add Dialogue for exiting
      if not direction:
        print() # TODO Dialogue to Choose Another Direction
    
    direction.enter(self.hero)
    # TODO Dialogue for entering new room


class Battle(Room):
  def __init__(self, north, east, south, west, enemy):
    super().__init__(north)
    super().__init__(east)
    super().__init__(south)
    super().__init__(west)
    super().__init__(enemy)

  def gold_calc(floor, kill_count):
    return np.random.choice[range(1* floor, 3*floor)] + (np.random.choice(range(kill_count // 4)))
    # Max luck: 3 * floor + kill_count // 4
    # Min luck: 1 * floor + 0
  
  def organ_calc(floor, kill_count):
    return  np.random.choice[range(math.ceil(1.5*floor), math.ceil(2.75*floor))]
    # Max luck: math.ceil(2.75 * floor)
    # Min luck: math.ceil(1.5*floor)
      
  def enter(self, hero):
    if not self.generated:
      super().enter(hero)
      self.battle(hero, self.enemy)
      self.upgrade()
    else:
      # TODO Dialogue stating you have been here already
      pass # TODO Delete
    self.exit() # TODO Add Dialogue for exiting

  def furnish(self, floor, kill_count, num_enemies): # Do Room Generation Function
    # super.furnish(self.floor, self.hero.kill_count, 0) # TODO Check If Works
    self.enemy = np.random.choice([Agent, LabBeast, Mutant])(floor, kill_count)
    weapon = np.random.choice([NanoSword, LaserGun, Hammer])(floor, kill_count)
    self.items[weapon.__name__] = weapon
    self.items['Gold'] = self.gold_calc(floor, kill_count)
    self.items['Organs'] = self.organ_calc(floor, kill_count)

  # TODO Add Battle Loop
  def battle(self, hero, enemy):
    # TODO Add Dialogue
    while hero.hp > 0:

      right_hand_moves = hero.right_hand.move_list
      if not hero.left_hand:
        left_hand_moves = []
      else:
        left_hand_moves = hero.left_hand.move_list
      
      hero.attack(enemy, pyip.inputMenu(left_hand_moves.append(right_hand_moves), '')) # TODO Add Dialogue
      
      if enemy.hp > 0:
        enemy.attack(hero)
      else:
        # TODO Win Dialogue
        print()
        return

    # TODO Game Over Dialogue
    # TODO Ask to Try Again, If Yes Clear and Run main() again

class BossRoom(Battle):
  def __init__(self, north, east, south, west, enemy):
    super().__init__(north)
    super().__init__(east)
    super().__init__(south)
    super().__init__(west)
    super().__init__(enemy)

  def furnish(self, floor, kill_count, num_enemies): # No Reward, Just Final Boss
    self.enemy = EvilScientist()

  def exit(self):
    print() # Game Win Dialogue


class Rest(Room):
  def __init__(self, north, east, south, west, enemy):
    super().__init__(north)
    super().__init__(east)
    super().__init__(south)
    super().__init__(west)
    super().__init__(enemy)
  
  def enter(self, hero):
    if not self.generated:
      self.hero = hero
      # TODO Rest Dialogue
      self.hero.restore_health(self.hero.max_hp)
      self.generated = True
    else:
      print() # TODO Dialogue stating you have been here already
    self.exit() # TODO Add Dialogue for exiting

class Treasure(Room):
  def __init__(self, north, east, south, west, enemy):
    super().__init__(north)
    super().__init__(east)
    super().__init__(south)
    super().__init__(west)
    super().__init__(enemy)
  
  def enter(self, hero):
    if not self.generated:
      super().enter(hero)
      self.generated = True
      self.upgrade()
    else:
      print() # TODO Dialogue stating you have been here already
    self.exit() # TODO Add Dialogue for exiting

class Shop(Room):
  def __init__(self, north, east, south, west, enemy):
    super().__init__(north)
    super().__init__(east)
    super().__init__(south)
    super().__init__(west)
    super().__init__(enemy)
    self.empty = False
    self.costs = {}
  
  def shop(self, continuing=''):
    # TODO Shop Keeper Dialogue
    shop_path = pyip.inputYesNo()  # TODO Asking If Want To Buy Something (Else) [If they are continuing shopping]
    if shop_path == 'Yes':
      if self.hero.gold < max(self.costs.values()):
        print() # TODO Broke Boy Dialogue
      else:
        bought = self.upgrade(self.costs)
        del self.items[bought]
        del self.costs[bought]
        if len(self.items.keys()) == 1:
            self.shop(' else')
        else:
          self.empty = True
          print() # TODO Dialogue for buying everything
    else:
      # TODO Exit Dialogue
      print()

  def furnish(self, floor, kill_count):
    super.furnish()
    for item in self.items.keys():
      if item == 'Organ':
        cost = 9
      else:
        cost = 20
      self.costs[item] = cost
  
  def enter(self, hero):
    if not self.generated:
      super().enter(hero)
    if not self.empty:
      self.shop()
      # TODO Dialogue stating you have been here already and shop is empty
    self.exit()  # TODO Add Dialogue for exiting
    # self.exit(pyip.inputMenu(['north', 'east', 'south', 'west'], ''))

# Create Rest Room

# Moves

# Guess a number to dinish Boss Super attack move?

def generate_level_one(floor_level):
  # Create all rooms
  r_1_0 = Treasure(floor_level)
  r_1_1 = Battle(floor_level)
  r_1_2 = Battle(floor_level)
  r_1_3 = Treasure(floor_level)
  r_1_4 = Battle(floor_level)
  r_1_5 = Battle(floor_level)
  r_1_6 = Battle(floor_level)
  r_1_7 = Rest(floor_level)
  r_1_8 = Battle(floor_level)
  r_1_9 = Treasure(floor_level)
  r_1_10 = Battle(floor_level)
  r_1_11 = Battle(floor_level)
  r_1_12 = Rest(floor_level)
  r_1_13 = Battle(floor_level)
  r_1_14 = Battle(floor_level) # Boss Room
  r_1_15 = Shop(floor_level)
  r_1_16 = Treasure(floor_level)
  r_1_17 = Battle(floor_level)

  # Connect all rooms
              # north, east, south, west
  r_1_0.connect(r_1_1, None, None, None)
  r_1_1.connect(r_1_2, r_1_10, None, None)
  r_1_2.connect(None, None, r_1_1, r_1_3)
  r_1_3.connect(None, r_1_2, r_1_4, None)
  r_1_4.connect(r_1_3, None, None, r_1_5)
  r_1_5.connect(r_1_6, r_1_4, None, None)
  r_1_6.connect(r_1_8, r_1_9, r_1_5, r_1_7)
  r_1_7.connect(None, r_1_6, None, None)
  r_1_8.connect(None, None, r_1_6, None)
  r_1_9.connect(None, None, None, r_1_6)
  r_1_10.connect(r_1_11, r_1_17, None, r_1_1)
  r_1_11.connect(r_1_12, r_1_16, r_1_10, None)
  r_1_12.connect(r_1_15, None, r_1_11, r_1_13)
  r_1_13.connect(r_1_14, r_1_12, None, None)
  r_1_14.connect(None, None, None, None) # Boss Room
  r_1_15.connect(None, None, r_1_12, None)
  r_1_16.connect(None, None, None, r_1_11)
  r_1_17.connect(None, None, None, r_1_10)

  return r_1_0

def main():
  # Generate field
  base = generate_level_one()

  # TODO Opening Words
  pyip.inputStr(prompt='Press "Enter" to begin', blank=True) # TODO Start Words
  player_name = pyip.inputStr(prompt='')

  # TODO Opening Cutscene
  
  hero_class_dict = {'corporate': Corporate, 'punk': Punk, 'detective': Detective} # TODO Put elsewhere
  hero_class = pyip.inputMenu(['Corporate', 'Punk', 'Detective'], prompt='')
  hero = hero_class_dict[hero_class](player_name) # Create hero 
  base.hero = hero
  # TODO Give hero stats

  # TODO Telling to head north
  base.exit()


  return